package protocol

import (
	"bytes"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestDecodeOkResponse(t *testing.T) {

	type DecodeOkResponseAssert struct {
		Packet   []byte
		HasError bool
		Error    error
		OkResponse
	}

	testData := []*DecodeOkResponseAssert{
		{
			[]byte{
				0x30, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x22, 0x00, 0x00, 0x00, 0x28, 0x52, 0x6f, 0x77, 0x73,
				0x20, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x3a, 0x20, 0x31, 0x20, 0x20, 0x43, 0x68, 0x61,
				0x6e, 0x67, 0x65, 0x64, 0x3a, 0x20, 0x31, 0x20, 0x20, 0x57, 0x61, 0x72, 0x6e, 0x69, 0x6e, 0x67,
				0x73, 0x3a, 0x20, 0x30,
			},
			false,
			nil,
			OkResponse{0x00, uint64(1), uint64(0)},
		},
		{
			[]byte{0x07, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00},
			false,
			nil,
			OkResponse{0x00, uint64(0), uint64(0)},
		},
		{
			[]byte{0x07, 0x00, 0x00, 0x01, 0x00, 0x01, 0x02, 0x02, 0x00, 0x00, 0x00},
			false,
			nil,
			OkResponse{0x00, uint64(1), uint64(2)},
		},
	}

	for _, asserted := range testData {
		decoded, err := DecodeOkResponse(asserted.Packet)

		assert.Nil(t, err)

		if err == nil {
			assert.Equal(t, asserted.OkResponse.PacketType, decoded.PacketType)
			assert.Equal(t, asserted.OkResponse.AffectedRows, decoded.AffectedRows)
			assert.Equal(t, asserted.OkResponse.LastInsertID, decoded.LastInsertID)
		}
	}
}

func TestDecodeHandshakeV10(t *testing.T) {

	type DecodeHandshakeV10Assert struct {
		Packet             []byte
		HasError           bool
		Error              error
		ProtocolVersion    byte
		ServerVersion      string
		ConnectionID       uint32
		AuthPlugin         string
		ServerCapabilities map[uint32]bool
	}

	testData := []*DecodeHandshakeV10Assert{
		{
			[]byte{
				0x4a, 0x00, 0x00, 0x00, 0x0a, 0x35, 0x2e, 0x35, 0x2e, 0x35, 0x36, 0x00, 0x5e, 0x06, 0x00, 0x00,
				0x48, 0x6a, 0x5b, 0x6a, 0x24, 0x71, 0x30, 0x3a, 0x00, 0xff, 0xf7, 0x08, 0x02, 0x00, 0x0f, 0x80,
				0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6f, 0x43, 0x40, 0x56, 0x6e,
				0x4b, 0x68, 0x4a, 0x79, 0x46, 0x30, 0x5a, 0x00, 0x6d, 0x79, 0x73, 0x71, 0x6c, 0x5f, 0x6e, 0x61,
				0x74, 0x69, 0x76, 0x65, 0x5f, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x00,
			},
			false,
			nil,
			byte(10),
			"5.5.56",
			uint32(1630),
			"mysql_native_password",
			map[uint32]bool{
				clientLongPassword: true, clientFoundRows: true, clientLongFlag: true,
				clientConnectWithDB: true, clientNoSchema: true, clientCompress: true, clientODBC: true,
				clientLocalFiles: true, clientIgnoreSpace: true, clientProtocol41: true, clientInteractive: true,
				clientSSL: false, clientIgnoreSIGPIPE: true, clientTransactions: true, clientMultiStatements: true,
				clientMultiResults: true, clientPSMultiResults: true, clientPluginAuth: true, clientConnectAttrs: false,
				clientPluginAuthLenEncClientData: false, clientCanHandleExpiredPasswords: false,
				clientSessionTrack: false, clientDeprecateEOF: false,
			},
		},
		{
			[]byte{
				0x4a, 0x00, 0x00, 0x00, 0x0a, 0x35, 0x2e, 0x37, 0x2e, 0x31, 0x38, 0x00, 0x0f, 0x00, 0x00, 0x00,
				0x15, 0x12, 0x4b, 0x1f, 0x70, 0x2b, 0x33, 0x55, 0x00, 0xff, 0xff, 0x08, 0x02, 0x00, 0xff, 0xc1,
				0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x30, 0x0d, 0x0a, 0x28,
				0x06, 0x4a, 0x12, 0x5e, 0x45, 0x18, 0x05, 0x00, 0x6d, 0x79, 0x73, 0x71, 0x6c, 0x5f, 0x6e, 0x61,
				0x74, 0x69, 0x76, 0x65, 0x5f, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x00,
			},
			false,
			nil,
			byte(10),
			"5.7.18",
			uint32(15),
			"mysql_native_password",
			map[uint32]bool{
				clientLongPassword: true, clientFoundRows: true, clientLongFlag: true,
				clientConnectWithDB: true, clientNoSchema: true, clientCompress: true, clientODBC: true,
				clientLocalFiles: true, clientIgnoreSpace: true, clientProtocol41: true, clientInteractive: true,
				clientSSL: true, clientIgnoreSIGPIPE: true, clientTransactions: true, clientMultiStatements: true,
				clientMultiResults: true, clientPSMultiResults: true, clientPluginAuth: true, clientConnectAttrs: true,
				clientPluginAuthLenEncClientData: true, clientCanHandleExpiredPasswords: true,
				clientSessionTrack: true, clientDeprecateEOF: true,
			},
		},
	}

	for _, asserted := range testData {
		decoded, err := DecodeHandshakeV10(asserted.Packet)

		if err != nil {
			assert.Equal(t, asserted.Error, err)
		} else {
			assert.Equal(t, asserted.ProtocolVersion, decoded.ProtocolVersion)
			assert.Equal(t, asserted.ServerVersion, decoded.ServerVersion)
			assert.Equal(t, asserted.ConnectionID, decoded.ConnectionID)
			assert.Equal(t, asserted.AuthPlugin, decoded.AuthPlugin)

			for flag, isSet := range asserted.ServerCapabilities {
				if isSet {
					assert.True(t, decoded.ServerCapabilities&flag > 0)
					if decoded.ServerCapabilities&flag == 0 {
						println(flag)
					}
				} else {
					assert.True(t, decoded.ServerCapabilities&flag == 0)
				}
			}
		}
	}
}

func TestDecodeComStmtExecuteRequest(t *testing.T) {

	type DecodeComStmtExecuteRequestAssert struct {
		Id                 int
		Packet             []byte
		HasError           bool
		Error              error
		StatementID        uint32
		PreparedParameters []string
	}

	testData := []*DecodeComStmtExecuteRequestAssert{
		{
			1,
			// Incorrect packet type
			[]byte{
				0x43, 0x00, 0x00, 0x00, 0x18, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01,
				0xfd, 0x00, 0xfd, 0x00, 0xfd, 0x00, 0x13, 0x31, 0x2e, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
				0x39, 0x31, 0x30, 0x31, 0x31, 0x31, 0x45, 0x2b, 0x32, 0x31, 0x06, 0x58, 0x59, 0x5a, 0x5a, 0x5a,
				0x5a, 0x15, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4b, 0x4c, 0x4d, 0x4f, 0x4e,
				0x50, 0x51, 0x52, 0x53, 0x54, 0x59, 0x57,
			},
			true,
			errInvalidPacketType,
			0,
			nil,
		},
		{
			2,
			// Incorrect packet length
			[]byte{0x43, 0x00, 0x00, 0x00, 0x17},
			true,
			errInvalidPacketLength,
			0,
			nil,
		},
		{
			3,
			// Correct packet with string params
			[]byte{
				0x43, 0x00, 0x00, 0x00, 0x17, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01,
				0xfd, 0x00, 0xfd, 0x00, 0xfd, 0x00, 0x13, 0x31, 0x2e, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
				0x39, 0x31, 0x30, 0x31, 0x31, 0x31, 0x45, 0x2b, 0x32, 0x31, 0x06, 0x58, 0x59, 0x5a, 0x5a, 0x5a,
				0x5a, 0x15, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4b, 0x4c, 0x4d, 0x4f, 0x4e,
				0x50, 0x51, 0x52, 0x53, 0x54, 0x59, 0x57,
			},
			false,
			nil,
			uint32(1),
			[]string{"1.2345678910111E+21", "XYZZZZ", "ABCDEFGHIKLMONPQRSTYW"},
		},
		{
			4,
			// Correct packet with string params and 0-length last param
			[]byte{
				0x6a, 0x00, 0x00, 0x00, 0x17, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01,
				0x01, 0xfd, 0x00, 0xfd, 0x00, 0xfd, 0x00, 0xfd, 0x00, 0xfd, 0x00, 0xfd, 0x00, 0xfd, 0x00, 0xfd,
				0x00, 0xfd, 0x00, 0x01, 0x30, 0x01, 0x30, 0x01, 0x30, 0x1a, 0x64, 0x68, 0x63, 0x35, 0x74, 0x62,
				0x6a, 0x32, 0x34, 0x31, 0x72, 0x61, 0x64, 0x64, 0x6d, 0x74, 0x6c, 0x76, 0x65, 0x32, 0x36, 0x72,
				0x76, 0x6b, 0x62, 0x76, 0x13, 0x32, 0x30, 0x31, 0x37, 0x2d, 0x30, 0x36, 0x2d, 0x32, 0x35, 0x20,
				0x31, 0x38, 0x3a, 0x31, 0x39, 0x3a, 0x32, 0x30, 0x0a, 0x32, 0x30, 0x31, 0x37, 0x2d, 0x30, 0x36,
				0x2d, 0x32, 0x35, 0x04, 0x61, 0x75, 0x74, 0x68, 0x05, 0x6c, 0x6f, 0x67, 0x69, 0x6e,
			},
			false,
			nil,
			uint32(2),
			[]string{"0", "0", "0", "dhc5tbj241raddmtlve26rvkbv", "2017-06-25 18:19:20", "2017-06-25", "auth", "login", ""},
		},
		{
			5,
			// Correct packet with string params and 0-length last param
			[]byte{
				0x6d, 0x00, 0x00, 0x00, 0x17, 0x71, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01,
				0x01, 0xfd, 0x00, 0xfd, 0x00, 0xfd, 0x00, 0xfd, 0x00, 0xfd, 0x00, 0xfd, 0x00, 0xfd, 0x00, 0xfd,
				0x00, 0xfd, 0x00, 0x01, 0x31, 0x01, 0x31, 0x01, 0x30, 0x1a, 0x64, 0x68, 0x63, 0x35, 0x74, 0x62,
				0x6a, 0x32, 0x34, 0x31, 0x72, 0x61, 0x64, 0x64, 0x6d, 0x74, 0x6c, 0x76, 0x65, 0x32, 0x36, 0x72,
				0x76, 0x6b, 0x62, 0x76, 0x13, 0x32, 0x30, 0x31, 0x37, 0x2d, 0x30, 0x36, 0x2d, 0x33, 0x30, 0x20,
				0x30, 0x39, 0x3a, 0x35, 0x36, 0x3a, 0x31, 0x38, 0x0a, 0x32, 0x30, 0x31, 0x37, 0x2d, 0x30, 0x36,
				0x2d, 0x33, 0x30, 0x07, 0x77, 0x69, 0x64, 0x67, 0x65, 0x74, 0x73, 0x05, 0x69, 0x6e, 0x64, 0x65,
				0x78,
			},
			false,
			nil,
			uint32(113),
			[]string{"1", "1", "0", "dhc5tbj241raddmtlve26rvkbv", "2017-06-30 09:56:18", "2017-06-30", "widgets", "index", ""},
		},
		{
			6,
			// Correct packet with longlong params
			[]byte{
				0x34, 0x00, 0x00, 0x00, 0x17, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01,
				0x08, 0x00, 0x08, 0x00, 0x05, 0x00, 0x05, 0x00, 0x39, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0xc7, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcd, 0xcc, 0xcc, 0xcc, 0xcc, 0xdc, 0x5e, 0x40,
				0xcd, 0xcc, 0xcc, 0xcc, 0xcc, 0xdc, 0x5e, 0xc0,
			},
			false,
			nil,
			uint32(1),
			[]string{"12345", "-12345", "123.450000", "-123.450000"},
		},
	}

	for _, asserted := range testData {
		decoded, err := DecodeComStmtExecuteRequest(asserted.Packet, uint16(len(asserted.PreparedParameters)))

		actualHasError := err != nil
		if asserted.HasError != actualHasError {
			t.Errorf("ID = %d expected(%t) and actual(%t) errors mismatch", asserted.Id, asserted.HasError, actualHasError)
			if actualHasError {
				t.Errorf("Actual error: %s", err.Error())
			}
		}

		if err != nil {
			assert.Equal(t, asserted.Error, err)
		} else {
			assert.Equal(t, asserted.StatementID, decoded.StatementID)

			for index, parameter := range decoded.PreparedParameters {
				assert.Equal(t, asserted.PreparedParameters[index], parameter.Value)
			}
		}
	}
}

func TestDecodeQueryRequest(t *testing.T) {

	type DecodeQueryRequestAssert struct {
		Packet   []byte
		Query    string
		HasError bool
		Error    error
	}

	testData := []*DecodeQueryRequestAssert{
		{
			// Incorrect packet length
			[]byte{0x00, 0x00, 0x00, 0x00, 0x00},
			"",
			true,
			errInvalidPacketLength,
		},
		{
			// Correct COM_QUERY packet
			[]byte{
				0x4a, 0x00, 0x00, 0x00, 0x03, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x20, 0x64, 0x61, 0x74, 0x61,
				0x62, 0x61, 0x73, 0x65, 0x28, 0x29, 0x2c, 0x20, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x28, 0x29,
				0x2c, 0x20, 0x6c, 0x65, 0x66, 0x74, 0x28, 0x75, 0x73, 0x65, 0x72, 0x28, 0x29, 0x2c, 0x69, 0x6e,
				0x73, 0x74, 0x72, 0x28, 0x63, 0x6f, 0x6e, 0x63, 0x61, 0x74, 0x28, 0x75, 0x73, 0x65, 0x72, 0x28,
				0x29, 0x2c, 0x27, 0x40, 0x27, 0x29, 0x2c, 0x27, 0x40, 0x27, 0x29, 0x2d, 0x31, 0x29,
			},
			"select database(), schema(), left(user(),instr(concat(user(),'@'),'@')-1)",
			false,
			nil,
		},
		{
			// Incorrect packet type
			[]byte{0x4a, 0x00, 0x00, 0x00, 0x05, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x20, 0x64, 0x61, 0x74},
			"",
			true,
			errInvalidPacketType,
		},
	}

	for _, asserted := range testData {
		decoded, err := DecodeQueryRequest(asserted.Packet)

		if err != nil {
			assert.Equal(t, asserted.Error, err)
		} else {
			assert.Equal(t, asserted.Query, decoded.Query)
		}
	}
}

func TestDecodeComStmtPrepareOkResponse(t *testing.T) {

	type DecodeComStmtPrepareOkResponseAssert struct {
		Packet        []byte
		HasError      bool
		Error         error
		StatementID   uint32
		ParametersNum uint16
	}

	testData := []*DecodeComStmtPrepareOkResponseAssert{
		{
			// Incorrect packet length
			[]byte{0x0c, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x04},
			true,
			errInvalidPacketLength,
			0,
			0,
		},
		{
			// Correct packet with StatementID = 1 and ParametersNum = 4
			[]byte{
				0x0c, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
			},
			false,
			nil,
			uint32(1),
			uint16(4),
		},
	}

	for _, asserted := range testData {
		decoded, err := DecodeComStmtPrepareOkResponse(asserted.Packet)

		if err != nil {
			assert.Equal(t, asserted.Error, err)
		} else {
			assert.Equal(t, asserted.StatementID, decoded.StatementID)
			assert.Equal(t, asserted.ParametersNum, decoded.ParametersNum)
		}
	}
}

//func TestReadLenEncodedString(t *testing.T) {
//	expected := "ABCDEFGHIKLMONPQRSTYW"
//	packet := []byte{
//		0x15, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4b, 0x4c, 0x4d, 0x4f, 0x4e, 0x50,
//		0x51, 0x52, 0x53, 0x54, 0x59, 0x57,
//	}
//
//	decoded, _ := ReadLenEncodedString(packet)
//
//	assert.Equal(t, expected, decoded)
//}

func TestReadEOFLengthString(t *testing.T) {
	expected := "SET sql_mode='STRICT_TRANS_TABLES'"
	encoded := []byte{
		0x53, 0x45, 0x54, 0x20, 0x73, 0x71, 0x6c, 0x5f, 0x6d, 0x6f, 0x64, 0x65, 0x3d, 0x27, 0x53, 0x54, 0x52,
		0x49, 0x43, 0x54, 0x5f, 0x54, 0x52, 0x41, 0x4e, 0x53, 0x5f, 0x54, 0x41, 0x42, 0x4c, 0x45, 0x53, 0x27,
	}

	decoded := ReadEOFLengthString(encoded)

	assert.Equal(t, expected, decoded)
}

func TestReadNullTerminatedString(t *testing.T) {
	x := bytes.NewReader([]byte{0x35, 0x2e, 0x37, 0x2e, 0x31, 0x38, 0x00})
	assert.Equal(t, "5.7.18", ReadNullTerminatedString(x))
}
